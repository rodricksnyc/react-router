{"version":3,"file":"calculate_suggest_options.js","names":["calculateSuggestOptions","filterTokenProps","max","options","values","value","isArray","find","val","take","existingValues","map","v","label","length","suggestionOptions","optionIndex","option","nth","pull","push","union","unfoundValues","difference"],"sources":["../../../../src/Filter/utils/calculate_suggest_options.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport difference from 'lodash/difference'\nimport find from 'lodash/find'\nimport isArray from 'lodash/isArray'\nimport map from 'lodash/map'\nimport take from 'lodash/take'\nimport union from 'lodash/union'\nimport nth from 'lodash/nth'\nimport pull from 'lodash/pull'\n\n/*\nCalculate the Suggestion Options based on max number of allowed\nvalues as well as pre-existing values on the filter which should show\nto allow de-selection\n*/\nexport const calculateSuggestOptions = (filterTokenProps: any) => {\n  const { max, options, value: values } = filterTokenProps\n\n  // if values is not an arary or is not an array containing a string\n  // return default\n  if (!isArray(values) || !find(values, (val) => typeof val === 'string')) {\n    return max ? take(options, max) : options\n  }\n\n  const existingValues =\n    map(values, (v) => find(options, { value: v }) || { value: v, label: v }) ||\n    []\n\n  // if there is a max limit, first use all existing values then options\n  // if there is no max, union all\n  if (max) {\n    // if there are more values than max, only show existing values\n    // else there is room to show other options\n    if (existingValues.length >= max) {\n      return take(existingValues, max)\n    } else {\n      const suggestionOptions: { value: string; label: string }[] = []\n      for (\n        let optionIndex = 0;\n        optionIndex < max - existingValues.length;\n        optionIndex++\n      ) {\n        const option = nth(options, optionIndex) as {\n          value: string\n          label: string\n        }\n        if (!option) {\n          break\n        }\n        pull(existingValues, option)\n        suggestionOptions.push(option)\n      }\n      return union(suggestionOptions, existingValues)\n    }\n  } else {\n    const unfoundValues = difference(existingValues, options) || []\n    return union(options, unfoundValues)\n  }\n}\n"],"mappings":";;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOO,IAAMA,uBAAuB,GAAG,SAA1BA,uBAAuB,CAAIC,gBAAqB,EAAK;EAChE,IAAQC,GAAG,GAA6BD,gBAAgB,CAAhDC,GAAG;IAAEC,OAAO,GAAoBF,gBAAgB,CAA3CE,OAAO;IAASC,MAAM,GAAKH,gBAAgB,CAAlCI,KAAK;;EAI3B,IAAI,CAAC,IAAAC,mBAAO,EAACF,MAAM,CAAC,IAAI,CAAC,IAAAG,gBAAI,EAACH,MAAM,EAAE,UAACI,GAAG;IAAA,OAAK,OAAOA,GAAG,KAAK,QAAQ;EAAA,EAAC,EAAE;IACvE,OAAON,GAAG,GAAG,IAAAO,gBAAI,EAACN,OAAO,EAAED,GAAG,CAAC,GAAGC,OAAO;EAC3C;EAEA,IAAMO,cAAc,GAClB,IAAAC,eAAG,EAACP,MAAM,EAAE,UAACQ,CAAC;IAAA,OAAK,IAAAL,gBAAI,EAACJ,OAAO,EAAE;MAAEE,KAAK,EAAEO;IAAE,CAAC,CAAC,IAAI;MAAEP,KAAK,EAAEO,CAAC;MAAEC,KAAK,EAAED;IAAE,CAAC;EAAA,EAAC,IACzE,EAAE;;EAIJ,IAAIV,GAAG,EAAE;IAGP,IAAIQ,cAAc,CAACI,MAAM,IAAIZ,GAAG,EAAE;MAChC,OAAO,IAAAO,gBAAI,EAACC,cAAc,EAAER,GAAG,CAAC;IAClC,CAAC,MAAM;MACL,IAAMa,iBAAqD,GAAG,EAAE;MAChE,KACE,IAAIC,WAAW,GAAG,CAAC,EACnBA,WAAW,GAAGd,GAAG,GAAGQ,cAAc,CAACI,MAAM,EACzCE,WAAW,EAAE,EACb;QACA,IAAMC,MAAM,GAAG,IAAAC,eAAG,EAACf,OAAO,EAAEa,WAAW,CAGtC;QACD,IAAI,CAACC,MAAM,EAAE;UACX;QACF;QACA,IAAAE,gBAAI,EAACT,cAAc,EAAEO,MAAM,CAAC;QAC5BF,iBAAiB,CAACK,IAAI,CAACH,MAAM,CAAC;MAChC;MACA,OAAO,IAAAI,iBAAK,EAACN,iBAAiB,EAAEL,cAAc,CAAC;IACjD;EACF,CAAC,MAAM;IACL,IAAMY,aAAa,GAAG,IAAAC,sBAAU,EAACb,cAAc,EAAEP,OAAO,CAAC,IAAI,EAAE;IAC/D,OAAO,IAAAkB,iBAAK,EAAClB,OAAO,EAAEmB,aAAa,CAAC;EACtC;AACF,CAAC;AAAA"}