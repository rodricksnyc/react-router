{"version":3,"file":"calculate_suggest_options.js","names":["difference","find","isArray","map","take","union","nth","pull","calculateSuggestOptions","filterTokenProps","max","options","value","values","val","existingValues","v","label","length","suggestionOptions","optionIndex","option","push","unfoundValues"],"sources":["../../../../src/Filter/utils/calculate_suggest_options.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport difference from 'lodash/difference'\nimport find from 'lodash/find'\nimport isArray from 'lodash/isArray'\nimport map from 'lodash/map'\nimport take from 'lodash/take'\nimport union from 'lodash/union'\nimport nth from 'lodash/nth'\nimport pull from 'lodash/pull'\n\n/*\nCalculate the Suggestion Options based on max number of allowed\nvalues as well as pre-existing values on the filter which should show\nto allow de-selection\n*/\nexport const calculateSuggestOptions = (filterTokenProps: any) => {\n  const { max, options, value: values } = filterTokenProps\n\n  // if values is not an arary or is not an array containing a string\n  // return default\n  if (!isArray(values) || !find(values, (val) => typeof val === 'string')) {\n    return max ? take(options, max) : options\n  }\n\n  const existingValues =\n    map(values, (v) => find(options, { value: v }) || { value: v, label: v }) ||\n    []\n\n  // if there is a max limit, first use all existing values then options\n  // if there is no max, union all\n  if (max) {\n    // if there are more values than max, only show existing values\n    // else there is room to show other options\n    if (existingValues.length >= max) {\n      return take(existingValues, max)\n    } else {\n      const suggestionOptions: { value: string; label: string }[] = []\n      for (\n        let optionIndex = 0;\n        optionIndex < max - existingValues.length;\n        optionIndex++\n      ) {\n        const option = nth(options, optionIndex) as {\n          value: string\n          label: string\n        }\n        if (!option) {\n          break\n        }\n        pull(existingValues, option)\n        suggestionOptions.push(option)\n      }\n      return union(suggestionOptions, existingValues)\n    }\n  } else {\n    const unfoundValues = difference(existingValues, options) || []\n    return union(options, unfoundValues)\n  }\n}\n"],"mappings":";;AAKA,OAAOA,UAAU,MAAM,mBAAmB;AAC1C,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAOC,OAAO,MAAM,gBAAgB;AACpC,OAAOC,GAAG,MAAM,YAAY;AAC5B,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAOC,KAAK,MAAM,cAAc;AAChC,OAAOC,GAAG,MAAM,YAAY;AAC5B,OAAOC,IAAI,MAAM,aAAa;;AAO9B,OAAO,MAAMC,uBAAuB,GAAIC,gBAAqB,IAAK;EAChE,MAAM;IAAEC,GAAG;IAAEC,OAAO;IAAEC,KAAK,EAAEC;EAAO,CAAC,GAAGJ,gBAAgB;;EAIxD,IAAI,CAACP,OAAO,CAACW,MAAM,CAAC,IAAI,CAACZ,IAAI,CAACY,MAAM,EAAGC,GAAG,IAAK,OAAOA,GAAG,KAAK,QAAQ,CAAC,EAAE;IACvE,OAAOJ,GAAG,GAAGN,IAAI,CAACO,OAAO,EAAED,GAAG,CAAC,GAAGC,OAAO;EAC3C;EAEA,MAAMI,cAAc,GAClBZ,GAAG,CAACU,MAAM,EAAGG,CAAC,IAAKf,IAAI,CAACU,OAAO,EAAE;IAAEC,KAAK,EAAEI;EAAE,CAAC,CAAC,IAAI;IAAEJ,KAAK,EAAEI,CAAC;IAAEC,KAAK,EAAED;EAAE,CAAC,CAAC,IACzE,EAAE;;EAIJ,IAAIN,GAAG,EAAE;IAGP,IAAIK,cAAc,CAACG,MAAM,IAAIR,GAAG,EAAE;MAChC,OAAON,IAAI,CAACW,cAAc,EAAEL,GAAG,CAAC;IAClC,CAAC,MAAM;MACL,MAAMS,iBAAqD,GAAG,EAAE;MAChE,KACE,IAAIC,WAAW,GAAG,CAAC,EACnBA,WAAW,GAAGV,GAAG,GAAGK,cAAc,CAACG,MAAM,EACzCE,WAAW,EAAE,EACb;QACA,MAAMC,MAAM,GAAGf,GAAG,CAACK,OAAO,EAAES,WAAW,CAGtC;QACD,IAAI,CAACC,MAAM,EAAE;UACX;QACF;QACAd,IAAI,CAACQ,cAAc,EAAEM,MAAM,CAAC;QAC5BF,iBAAiB,CAACG,IAAI,CAACD,MAAM,CAAC;MAChC;MACA,OAAOhB,KAAK,CAACc,iBAAiB,EAAEJ,cAAc,CAAC;IACjD;EACF,CAAC,MAAM;IACL,MAAMQ,aAAa,GAAGvB,UAAU,CAACe,cAAc,EAAEJ,OAAO,CAAC,IAAI,EAAE;IAC/D,OAAON,KAAK,CAACM,OAAO,EAAEY,aAAa,CAAC;EACtC;AACF,CAAC"}