{"version":3,"file":"parse_filter_expression.js","names":["generateParser","parserCache","type","grammar","generate","parserOptions","Object","getNumberFromString","parseFilterExpression","expression","userAttributes","typeToGrammar","anyvalue","transform","root","parser","transforms","userAttributeTransform","transformAST","parse","error","getMatchesAdvancedNode"],"sources":["../../../src/utils/parse_filter_expression.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport type { Parser } from 'pegjs'\nimport { generate } from 'pegjs'\nimport type {\n  FilterASTNode,\n  FilterExpressionType,\n  TransformFunction,\n  UserAttributeWithValue,\n} from '../types'\nimport { getNumberFromString } from './number/get_number_from_string'\nimport { getMatchesAdvancedNode } from './get_matches_advanced_node'\nimport { transformAST } from './transform/transform_ast'\nimport { userAttributeTransform } from './transform/userAttributeTransform'\nimport { typeToGrammar } from './type_to_grammar'\n\n/**\n * Generates a parser from a PEGjs grammar and caches the result\n */\nconst generateParser = (() => {\n  const parserCache: { [key: string]: Parser } = {}\n  return (type: string, grammar: string) => {\n    if (!parserCache[type]) {\n      parserCache[type] = generate(grammar)\n    }\n    return parserCache[type]\n  }\n})()\n\n/**\n * Variables used inside grammars\n */\nexport const parserOptions = { Object, getNumberFromString }\n\n/**\n * A functions that uses a grammar of type type to parse an expression and returns an AST\n */\nexport const parseFilterExpression = (\n  type: FilterExpressionType,\n  expression: string,\n  userAttributes?: UserAttributeWithValue[]\n): FilterASTNode => {\n  const {\n    grammar,\n    anyvalue,\n    transform = (root: FilterASTNode) => root,\n  } = typeToGrammar(type)\n  if (expression === '') {\n    return anyvalue\n  }\n  try {\n    const parser = generateParser(type, grammar)\n    const transforms: TransformFunction[] = [\n      userAttributeTransform(userAttributes),\n      transform,\n    ]\n    return transformAST(parser.parse(expression, parserOptions), transforms)\n  } catch (error) {\n    return getMatchesAdvancedNode(expression)\n  }\n}\n"],"mappings":";;;;;;AAKA;AAOA;AACA;AACA;AACA;AACA;;AAKA,IAAMA,cAAc,GAAI,YAAM;EAC5B,IAAMC,WAAsC,GAAG,CAAC,CAAC;EACjD,OAAO,UAACC,IAAY,EAAEC,OAAe,EAAK;IACxC,IAAI,CAACF,WAAW,CAACC,IAAI,CAAC,EAAE;MACtBD,WAAW,CAACC,IAAI,CAAC,GAAG,IAAAE,eAAQ,EAACD,OAAO,CAAC;IACvC;IACA,OAAOF,WAAW,CAACC,IAAI,CAAC;EAC1B,CAAC;AACH,CAAC,EAAG;;AAKG,IAAMG,aAAa,GAAG;EAAEC,MAAM,EAANA,MAAM;EAAEC,mBAAmB,EAAnBA;AAAoB,CAAC;;AAAA;AAKrD,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqB,CAChCN,IAA0B,EAC1BO,UAAkB,EAClBC,cAAyC,EACvB;EAClB,qBAII,IAAAC,8BAAa,EAACT,IAAI,CAAC;IAHrBC,OAAO,kBAAPA,OAAO;IACPS,QAAQ,kBAARA,QAAQ;IAAA,uCACRC,SAAS;IAATA,SAAS,sCAAG,UAACC,IAAmB;MAAA,OAAKA,IAAI;IAAA;EAE3C,IAAIL,UAAU,KAAK,EAAE,EAAE;IACrB,OAAOG,QAAQ;EACjB;EACA,IAAI;IACF,IAAMG,MAAM,GAAGf,cAAc,CAACE,IAAI,EAAEC,OAAO,CAAC;IAC5C,IAAMa,UAA+B,GAAG,CACtC,IAAAC,8CAAsB,EAACP,cAAc,CAAC,EACtCG,SAAS,CACV;IACD,OAAO,IAAAK,2BAAY,EAACH,MAAM,CAACI,KAAK,CAACV,UAAU,EAAEJ,aAAa,CAAC,EAAEW,UAAU,CAAC;EAC1E,CAAC,CAAC,OAAOI,KAAK,EAAE;IACd,OAAO,IAAAC,iDAAsB,EAACZ,UAAU,CAAC;EAC3C;AACF,CAAC;AAAA"}