{"version":3,"file":"numberTransform.js","names":["countNots","root","count","inorderTraversal","node","is","removeDuplicateNotNodes","workingRoot","cloneDeep","applyId","andClauses","treeToList","filter","item","length","serializeNumberNode","removeNode","id","numberTransform","countOfNotNodes","mergeNodesWithDifferentIsValue","mergedRoot","mergeMultiValueNodes","NumberTypes","EQUAL","checkForDuplicates"],"sources":["../../../../src/utils/transform/numberTransform.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport cloneDeep from 'lodash/cloneDeep'\nimport type { FilterASTNode } from '../../types'\nimport { NumberTypes } from '../../types/number_types'\nimport { serializeNumberNode } from '../number/number_to_string'\nimport { inorderTraversal, removeNode, treeToList } from '../tree'\nimport { mergeMultiValueNodes } from './mergeMultiValueNodes'\nimport applyId from './utils/apply_id_to_ast'\n\n/**\n * Traverses ast and returns the count of 'not' nodes ('is' value set to false)\n */\nconst countNots = (root: FilterASTNode): number => {\n  let count = 0\n  inorderTraversal(root, (node) => {\n    if (node.is === false) {\n      count += 1\n    }\n  })\n  return count\n}\n\n/**\n * when two duplicate \"is not\" nodes are present\n * removes the second one\n */\nconst removeDuplicateNotNodes = (root: FilterASTNode) => {\n  const workingRoot = cloneDeep(applyId(root))\n  // get the andClauses - \"is not\" nodes from the ast\n  const andClauses = treeToList(workingRoot).filter((item) => item.is === false)\n  // we only care if there are two andClauses with the same expression\n  return andClauses.length === 2 &&\n    serializeNumberNode(andClauses[0]) === serializeNumberNode(andClauses[1])\n    ? // remove the second one\n      removeNode(workingRoot, andClauses[1].id) || {}\n    : workingRoot\n}\n\n/**\n * Applies the following transformations on the number AST:\n *  - combine the value array on nodes of type '='\n */\nexport const numberTransform = (root: FilterASTNode): FilterASTNode => {\n  // workaround for inconsistency in number filter and allow merging of nodes\n  // with different 'is' value: 1, not 2 -> becomes\n  // a single filter node { type: '=', is: false, value: [1, 2] }\n  const countOfNotNodes = countNots(root)\n  const mergeNodesWithDifferentIsValue = countOfNotNodes === 1\n\n  const mergedRoot = mergeMultiValueNodes(\n    root,\n    NumberTypes.EQUAL,\n    mergeNodesWithDifferentIsValue\n  )\n\n  // if there are two \"is not\" nodes check if they are duplicates\n  // to undo the \"fix\" applied when serializing the number filter\n  const checkForDuplicates = countOfNotNodes === 2\n  return checkForDuplicates ? removeDuplicateNotNodes(mergedRoot) : mergedRoot\n}\n"],"mappings":";;;;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;;AAKA,IAAMA,SAAS,GAAG,SAAZA,SAAS,CAAIC,IAAmB,EAAa;EACjD,IAAIC,KAAK,GAAG,CAAC;EACb,IAAAC,sBAAgB,EAACF,IAAI,EAAE,UAACG,IAAI,EAAK;IAC/B,IAAIA,IAAI,CAACC,EAAE,KAAK,KAAK,EAAE;MACrBH,KAAK,IAAI,CAAC;IACZ;EACF,CAAC,CAAC;EACF,OAAOA,KAAK;AACd,CAAC;;AAMD,IAAMI,uBAAuB,GAAG,SAA1BA,uBAAuB,CAAIL,IAAmB,EAAK;EACvD,IAAMM,WAAW,GAAG,IAAAC,qBAAS,EAAC,IAAAC,2BAAO,EAACR,IAAI,CAAC,CAAC;EAE5C,IAAMS,UAAU,GAAG,IAAAC,gBAAU,EAACJ,WAAW,CAAC,CAACK,MAAM,CAAC,UAACC,IAAI;IAAA,OAAKA,IAAI,CAACR,EAAE,KAAK,KAAK;EAAA,EAAC;EAE9E,OAAOK,UAAU,CAACI,MAAM,KAAK,CAAC,IAC5B,IAAAC,qCAAmB,EAACL,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,IAAAK,qCAAmB,EAACL,UAAU,CAAC,CAAC,CAAC,CAAC;EAEvE,IAAAM,gBAAU,EAACT,WAAW,EAAEG,UAAU,CAAC,CAAC,CAAC,CAACO,EAAE,CAAC,IAAI,CAAC,CAAC,GAC/CV,WAAW;AACjB,CAAC;;AAMM,IAAMW,eAAe,GAAG,SAAlBA,eAAe,CAAIjB,IAAmB,EAAoB;EAIrE,IAAMkB,eAAe,GAAGnB,SAAS,CAACC,IAAI,CAAC;EACvC,IAAMmB,8BAA8B,GAAGD,eAAe,KAAK,CAAC;EAE5D,IAAME,UAAU,GAAG,IAAAC,0CAAoB,EACrCrB,IAAI,EACJsB,yBAAW,CAACC,KAAK,EACjBJ,8BAA8B,CAC/B;;EAID,IAAMK,kBAAkB,GAAGN,eAAe,KAAK,CAAC;EAChD,OAAOM,kBAAkB,GAAGnB,uBAAuB,CAACe,UAAU,CAAC,GAAGA,UAAU;AAC9E,CAAC;AAAA"}