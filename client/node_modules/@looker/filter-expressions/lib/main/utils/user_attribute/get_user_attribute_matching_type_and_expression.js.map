{"version":3,"file":"get_user_attribute_matching_type_and_expression.js","names":["getUserAttributeMatchingTypeAndExpression","type","expression","userAttributes","ast","parseFilterExpression","find","ua","name","attributeName"],"sources":["../../../../src/utils/user_attribute/get_user_attribute_matching_type_and_expression.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport type { UserAttributeWithValue, FilterExpressionType } from '../../types'\nimport { parseFilterExpression } from '../parse_filter_expression'\n\n/**\n * Returns the user attribute matching the filter \"type\" and \"expression\".\n * If no matching user attribute is found, we return `null`.\n *\n * For example, if we have those parameters:\n * - type: 'string'\n * - expression: `{{ _user_attributes['xyz'] }}`\n * - userAttributes: [{ name: 'xyz', otherUserAttributeData... }]\n *\n * ... the expression will be parsed and we'll be able to successfully\n * match the AST with the \"xyz\" user attribute, which we will return.\n *\n * @param type the filter type\n * @param expression the value of the filter (which should contain the name of the user attribute)\n * @param userAttributes the list of user attributes where we should look\n */\nexport const getUserAttributeMatchingTypeAndExpression = (\n  type: FilterExpressionType,\n  expression = '',\n  userAttributes?: UserAttributeWithValue[]\n): UserAttributeWithValue | null => {\n  const ast = parseFilterExpression(type, expression, userAttributes)\n  return userAttributes?.find((ua) => ua.name === ast.attributeName) || null\n}\n"],"mappings":";;;;;;AAKA;;AAkBO,IAAMA,yCAAyC,GAAG,SAA5CA,yCAAyC,CACpDC,IAA0B,EAGQ;EAAA,IAFlCC,UAAU,uEAAG,EAAE;EAAA,IACfC,cAAyC;EAEzC,IAAMC,GAAG,GAAG,IAAAC,8CAAqB,EAACJ,IAAI,EAAEC,UAAU,EAAEC,cAAc,CAAC;EACnE,OAAO,CAAAA,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEG,IAAI,CAAC,UAACC,EAAE;IAAA,OAAKA,EAAE,CAACC,IAAI,KAAKJ,GAAG,CAACK,aAAa;EAAA,EAAC,KAAI,IAAI;AAC5E,CAAC;AAAA"}