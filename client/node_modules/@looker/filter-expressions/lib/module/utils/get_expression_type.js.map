{"version":3,"file":"get_expression_type.js","names":["Category","getTimeframeExpressionType","fieldType","isDateTime","some","timeString","indexOf","getExpressionTypeFromField","field","category","parameter","type","enumerations","is_numeric","is_timeframe","getExpressionType","filter","filterExpressionMap","number_filter","string_filter","date_filter","field_filter"],"sources":["../../../src/utils/get_expression_type.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport { Category } from '@looker/sdk'\nimport type { IDashboardFilter, ILookmlModelExploreField } from '@looker/sdk'\nimport type { FilterExpressionType } from '../types/filter_type'\n\ninterface FilterExpressionTypeMap {\n  [type: string]: FilterExpressionType\n}\n\nconst getTimeframeExpressionType = (fieldType?: string) => {\n  if (!fieldType) return 'date'\n\n  const isDateTime = ['date_time', 'hour', 'minute', 'second'].some(\n    (timeString: string) => {\n      return fieldType.indexOf(timeString) > -1\n    }\n  )\n  if (isDateTime) return 'date_time'\n\n  return 'date'\n}\n\n/**\n * yields a value for the 'expressionType' prop on the Filter component\n */\nexport const getExpressionTypeFromField = (\n  field: ILookmlModelExploreField\n): FilterExpressionType => {\n  if (field?.category === Category.parameter && field?.type === 'number') {\n    // If parameter field has enumerations it always parsed as 'tier' but\n    // visually should be treated differently if number type defined in LookML\n    // bugs: b/187940941, b/199507872\n    return field.type as FilterExpressionType\n  }\n  if (field.enumerations) {\n    return 'tier'\n  }\n  if (field.is_numeric) {\n    return 'number'\n  }\n  if (field.is_timeframe) {\n    return getTimeframeExpressionType(field.type)\n  }\n  if (field.type === 'location' || field.type === 'location_bin_level') {\n    return 'location'\n  }\n  return 'string'\n}\n\n/**\n * Returns a valid filter expression type from a DashboardFilter object\n * depending if the filter is of type field or not\n */\nexport const getExpressionType = (\n  filter: Pick<IDashboardFilter, 'type' | 'field'>\n): FilterExpressionType => {\n  if (filter.field) {\n    return getExpressionTypeFromField(filter.field)\n  }\n\n  const filterExpressionMap: FilterExpressionTypeMap = {\n    number_filter: 'number',\n    string_filter: 'string',\n    date_filter: 'date',\n    // Catch for broken cases where field is not defined, display as a\n    // string filter\n    field_filter: 'string',\n  }\n  return filterExpressionMap[filter.type ?? 'field_filter']\n}\n"],"mappings":";AAIA,SAASA,QAAQ,QAAQ,aAAa;AAQtC,MAAMC,0BAA0B,GAAIC,SAAkB,IAAK;EACzD,IAAI,CAACA,SAAS,EAAE,OAAO,MAAM;EAE7B,MAAMC,UAAU,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAACC,IAAI,CAC9DC,UAAkB,IAAK;IACtB,OAAOH,SAAS,CAACI,OAAO,CAACD,UAAU,CAAC,GAAG,CAAC,CAAC;EAC3C,CAAC,CACF;EACD,IAAIF,UAAU,EAAE,OAAO,WAAW;EAElC,OAAO,MAAM;AACf,CAAC;;AAKD,OAAO,MAAMI,0BAA0B,GACrCC,KAA+B,IACN;EACzB,IAAI,CAAAA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,QAAQ,MAAKT,QAAQ,CAACU,SAAS,IAAI,CAAAF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEG,IAAI,MAAK,QAAQ,EAAE;IAItE,OAAOH,KAAK,CAACG,IAAI;EACnB;EACA,IAAIH,KAAK,CAACI,YAAY,EAAE;IACtB,OAAO,MAAM;EACf;EACA,IAAIJ,KAAK,CAACK,UAAU,EAAE;IACpB,OAAO,QAAQ;EACjB;EACA,IAAIL,KAAK,CAACM,YAAY,EAAE;IACtB,OAAOb,0BAA0B,CAACO,KAAK,CAACG,IAAI,CAAC;EAC/C;EACA,IAAIH,KAAK,CAACG,IAAI,KAAK,UAAU,IAAIH,KAAK,CAACG,IAAI,KAAK,oBAAoB,EAAE;IACpE,OAAO,UAAU;EACnB;EACA,OAAO,QAAQ;AACjB,CAAC;;AAMD,OAAO,MAAMI,iBAAiB,GAC5BC,MAAgD,IACvB;EAAA;EACzB,IAAIA,MAAM,CAACR,KAAK,EAAE;IAChB,OAAOD,0BAA0B,CAACS,MAAM,CAACR,KAAK,CAAC;EACjD;EAEA,MAAMS,mBAA4C,GAAG;IACnDC,aAAa,EAAE,QAAQ;IACvBC,aAAa,EAAE,QAAQ;IACvBC,WAAW,EAAE,MAAM;IAGnBC,YAAY,EAAE;EAChB,CAAC;EACD,OAAOJ,mBAAmB,iBAACD,MAAM,CAACL,IAAI,uDAAI,cAAc,CAAC;AAC3D,CAAC"}