{"version":3,"file":"parse_filter_expression.js","names":["generate","getNumberFromString","getMatchesAdvancedNode","transformAST","userAttributeTransform","typeToGrammar","generateParser","parserCache","type","grammar","parserOptions","Object","parseFilterExpression","expression","userAttributes","anyvalue","transform","root","parser","transforms","parse","error"],"sources":["../../../src/utils/parse_filter_expression.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport type { Parser } from 'pegjs'\nimport { generate } from 'pegjs'\nimport type {\n  FilterASTNode,\n  FilterExpressionType,\n  TransformFunction,\n  UserAttributeWithValue,\n} from '../types'\nimport { getNumberFromString } from './number/get_number_from_string'\nimport { getMatchesAdvancedNode } from './get_matches_advanced_node'\nimport { transformAST } from './transform/transform_ast'\nimport { userAttributeTransform } from './transform/userAttributeTransform'\nimport { typeToGrammar } from './type_to_grammar'\n\n/**\n * Generates a parser from a PEGjs grammar and caches the result\n */\nconst generateParser = (() => {\n  const parserCache: { [key: string]: Parser } = {}\n  return (type: string, grammar: string) => {\n    if (!parserCache[type]) {\n      parserCache[type] = generate(grammar)\n    }\n    return parserCache[type]\n  }\n})()\n\n/**\n * Variables used inside grammars\n */\nexport const parserOptions = { Object, getNumberFromString }\n\n/**\n * A functions that uses a grammar of type type to parse an expression and returns an AST\n */\nexport const parseFilterExpression = (\n  type: FilterExpressionType,\n  expression: string,\n  userAttributes?: UserAttributeWithValue[]\n): FilterASTNode => {\n  const {\n    grammar,\n    anyvalue,\n    transform = (root: FilterASTNode) => root,\n  } = typeToGrammar(type)\n  if (expression === '') {\n    return anyvalue\n  }\n  try {\n    const parser = generateParser(type, grammar)\n    const transforms: TransformFunction[] = [\n      userAttributeTransform(userAttributes),\n      transform,\n    ]\n    return transformAST(parser.parse(expression, parserOptions), transforms)\n  } catch (error) {\n    return getMatchesAdvancedNode(expression)\n  }\n}\n"],"mappings":";;AAKA,SAASA,QAAQ,QAAQ,OAAO;AAOhC,SAASC,mBAAmB,QAAQ,iCAAiC;AACrE,SAASC,sBAAsB,QAAQ,6BAA6B;AACpE,SAASC,YAAY,QAAQ,2BAA2B;AACxD,SAASC,sBAAsB,QAAQ,oCAAoC;AAC3E,SAASC,aAAa,QAAQ,mBAAmB;;AAKjD,MAAMC,cAAc,GAAG,CAAC,MAAM;EAC5B,MAAMC,WAAsC,GAAG,CAAC,CAAC;EACjD,OAAO,CAACC,IAAY,EAAEC,OAAe,KAAK;IACxC,IAAI,CAACF,WAAW,CAACC,IAAI,CAAC,EAAE;MACtBD,WAAW,CAACC,IAAI,CAAC,GAAGR,QAAQ,CAACS,OAAO,CAAC;IACvC;IACA,OAAOF,WAAW,CAACC,IAAI,CAAC;EAC1B,CAAC;AACH,CAAC,GAAG;;AAKJ,OAAO,MAAME,aAAa,GAAG;EAAEC,MAAM;EAAEV;AAAoB,CAAC;;AAK5D,OAAO,MAAMW,qBAAqB,GAAG,CACnCJ,IAA0B,EAC1BK,UAAkB,EAClBC,cAAyC,KACvB;EAClB,MAAM;IACJL,OAAO;IACPM,QAAQ;IACRC,SAAS,GAAIC,IAAmB,IAAKA;EACvC,CAAC,GAAGZ,aAAa,CAACG,IAAI,CAAC;EACvB,IAAIK,UAAU,KAAK,EAAE,EAAE;IACrB,OAAOE,QAAQ;EACjB;EACA,IAAI;IACF,MAAMG,MAAM,GAAGZ,cAAc,CAACE,IAAI,EAAEC,OAAO,CAAC;IAC5C,MAAMU,UAA+B,GAAG,CACtCf,sBAAsB,CAACU,cAAc,CAAC,EACtCE,SAAS,CACV;IACD,OAAOb,YAAY,CAACe,MAAM,CAACE,KAAK,CAACP,UAAU,EAAEH,aAAa,CAAC,EAAES,UAAU,CAAC;EAC1E,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd,OAAOnB,sBAAsB,CAACW,UAAU,CAAC;EAC3C;AACF,CAAC"}