{"version":3,"file":"numberTransform.js","names":["cloneDeep","NumberTypes","serializeNumberNode","inorderTraversal","removeNode","treeToList","mergeMultiValueNodes","applyId","countNots","root","count","node","is","removeDuplicateNotNodes","workingRoot","andClauses","filter","item","length","id","numberTransform","countOfNotNodes","mergeNodesWithDifferentIsValue","mergedRoot","EQUAL","checkForDuplicates"],"sources":["../../../../src/utils/transform/numberTransform.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport cloneDeep from 'lodash/cloneDeep'\nimport type { FilterASTNode } from '../../types'\nimport { NumberTypes } from '../../types/number_types'\nimport { serializeNumberNode } from '../number/number_to_string'\nimport { inorderTraversal, removeNode, treeToList } from '../tree'\nimport { mergeMultiValueNodes } from './mergeMultiValueNodes'\nimport applyId from './utils/apply_id_to_ast'\n\n/**\n * Traverses ast and returns the count of 'not' nodes ('is' value set to false)\n */\nconst countNots = (root: FilterASTNode): number => {\n  let count = 0\n  inorderTraversal(root, (node) => {\n    if (node.is === false) {\n      count += 1\n    }\n  })\n  return count\n}\n\n/**\n * when two duplicate \"is not\" nodes are present\n * removes the second one\n */\nconst removeDuplicateNotNodes = (root: FilterASTNode) => {\n  const workingRoot = cloneDeep(applyId(root))\n  // get the andClauses - \"is not\" nodes from the ast\n  const andClauses = treeToList(workingRoot).filter((item) => item.is === false)\n  // we only care if there are two andClauses with the same expression\n  return andClauses.length === 2 &&\n    serializeNumberNode(andClauses[0]) === serializeNumberNode(andClauses[1])\n    ? // remove the second one\n      removeNode(workingRoot, andClauses[1].id) || {}\n    : workingRoot\n}\n\n/**\n * Applies the following transformations on the number AST:\n *  - combine the value array on nodes of type '='\n */\nexport const numberTransform = (root: FilterASTNode): FilterASTNode => {\n  // workaround for inconsistency in number filter and allow merging of nodes\n  // with different 'is' value: 1, not 2 -> becomes\n  // a single filter node { type: '=', is: false, value: [1, 2] }\n  const countOfNotNodes = countNots(root)\n  const mergeNodesWithDifferentIsValue = countOfNotNodes === 1\n\n  const mergedRoot = mergeMultiValueNodes(\n    root,\n    NumberTypes.EQUAL,\n    mergeNodesWithDifferentIsValue\n  )\n\n  // if there are two \"is not\" nodes check if they are duplicates\n  // to undo the \"fix\" applied when serializing the number filter\n  const checkForDuplicates = countOfNotNodes === 2\n  return checkForDuplicates ? removeDuplicateNotNodes(mergedRoot) : mergedRoot\n}\n"],"mappings":";AAIA,OAAOA,SAAS,MAAM,kBAAkB;AAExC,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,mBAAmB,QAAQ,4BAA4B;AAChE,SAASC,gBAAgB,EAAEC,UAAU,EAAEC,UAAU,QAAQ,SAAS;AAClE,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,OAAOC,OAAO,MAAM,yBAAyB;;AAK7C,MAAMC,SAAS,GAAIC,IAAmB,IAAa;EACjD,IAAIC,KAAK,GAAG,CAAC;EACbP,gBAAgB,CAACM,IAAI,EAAGE,IAAI,IAAK;IAC/B,IAAIA,IAAI,CAACC,EAAE,KAAK,KAAK,EAAE;MACrBF,KAAK,IAAI,CAAC;IACZ;EACF,CAAC,CAAC;EACF,OAAOA,KAAK;AACd,CAAC;;AAMD,MAAMG,uBAAuB,GAAIJ,IAAmB,IAAK;EACvD,MAAMK,WAAW,GAAGd,SAAS,CAACO,OAAO,CAACE,IAAI,CAAC,CAAC;EAE5C,MAAMM,UAAU,GAAGV,UAAU,CAACS,WAAW,CAAC,CAACE,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACL,EAAE,KAAK,KAAK,CAAC;EAE9E,OAAOG,UAAU,CAACG,MAAM,KAAK,CAAC,IAC5BhB,mBAAmB,CAACa,UAAU,CAAC,CAAC,CAAC,CAAC,KAAKb,mBAAmB,CAACa,UAAU,CAAC,CAAC,CAAC,CAAC;EAEvEX,UAAU,CAACU,WAAW,EAAEC,UAAU,CAAC,CAAC,CAAC,CAACI,EAAE,CAAC,IAAI,CAAC,CAAC,GAC/CL,WAAW;AACjB,CAAC;;AAMD,OAAO,MAAMM,eAAe,GAAIX,IAAmB,IAAoB;EAIrE,MAAMY,eAAe,GAAGb,SAAS,CAACC,IAAI,CAAC;EACvC,MAAMa,8BAA8B,GAAGD,eAAe,KAAK,CAAC;EAE5D,MAAME,UAAU,GAAGjB,oBAAoB,CACrCG,IAAI,EACJR,WAAW,CAACuB,KAAK,EACjBF,8BAA8B,CAC/B;;EAID,MAAMG,kBAAkB,GAAGJ,eAAe,KAAK,CAAC;EAChD,OAAOI,kBAAkB,GAAGZ,uBAAuB,CAACU,UAAU,CAAC,GAAGA,UAAU;AAC9E,CAAC"}