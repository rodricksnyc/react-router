{"version":3,"file":"get_user_attribute_matching_type_and_expression.js","names":["parseFilterExpression","getUserAttributeMatchingTypeAndExpression","type","expression","userAttributes","ast","find","ua","name","attributeName"],"sources":["../../../../src/utils/user_attribute/get_user_attribute_matching_type_and_expression.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport type { UserAttributeWithValue, FilterExpressionType } from '../../types'\nimport { parseFilterExpression } from '../parse_filter_expression'\n\n/**\n * Returns the user attribute matching the filter \"type\" and \"expression\".\n * If no matching user attribute is found, we return `null`.\n *\n * For example, if we have those parameters:\n * - type: 'string'\n * - expression: `{{ _user_attributes['xyz'] }}`\n * - userAttributes: [{ name: 'xyz', otherUserAttributeData... }]\n *\n * ... the expression will be parsed and we'll be able to successfully\n * match the AST with the \"xyz\" user attribute, which we will return.\n *\n * @param type the filter type\n * @param expression the value of the filter (which should contain the name of the user attribute)\n * @param userAttributes the list of user attributes where we should look\n */\nexport const getUserAttributeMatchingTypeAndExpression = (\n  type: FilterExpressionType,\n  expression = '',\n  userAttributes?: UserAttributeWithValue[]\n): UserAttributeWithValue | null => {\n  const ast = parseFilterExpression(type, expression, userAttributes)\n  return userAttributes?.find((ua) => ua.name === ast.attributeName) || null\n}\n"],"mappings":";;AAKA,SAASA,qBAAqB,QAAQ,4BAA4B;;AAkBlE,OAAO,MAAMC,yCAAyC,GAAG,CACvDC,IAA0B,EAC1BC,UAAU,GAAG,EAAE,EACfC,cAAyC,KACP;EAClC,MAAMC,GAAG,GAAGL,qBAAqB,CAACE,IAAI,EAAEC,UAAU,EAAEC,cAAc,CAAC;EACnE,OAAO,CAAAA,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEE,IAAI,CAAEC,EAAE,IAAKA,EAAE,CAACC,IAAI,KAAKH,GAAG,CAACI,aAAa,CAAC,KAAI,IAAI;AAC5E,CAAC"}